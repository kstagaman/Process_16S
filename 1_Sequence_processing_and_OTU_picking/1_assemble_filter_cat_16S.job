#!/bin/bash
# 1_assemble_filter_cat_16.job

### Use the script to assemble, quality filter, and concatenate paired-end illumina 16S sequences. 
# This script requires that the sequences have been demultiplexed and 
# each sample file pair has the following format: 
#     sample_name-R1.fastq
#     sample_name-R2.fastq 
#     (where sample_name is the sample ID not containing any -'s or .'s)

### Auxillary scripts and programs
# flash
# fastx_toolkit
# seqtk
# batch_rename.sh

###################### YOU CAN EDIT THE FOLLOWING VARIABLES ###################### 
rawDir=/ssd/stagamak_tmp/Practice_16S
scriptsDir=/home/micro/stagamak/scripts/Process_16S/Support_scripts
nproc=80 # number of processors to use during steps that allow parallelization

### Flash variables
flash_minOverlap=20 
flash_maxOverlap=150 # 247 min and max are what I used for PE250 reads of the V4 region, 20min, 150max for PE150 reads
flash_mismatch=0.25 # increasing this leads to more assemblies made, but increases error rate

### Quality filtering variables (fastq_quality_filter)
qual_min=20
qual_pct=95

##################################################################################
########### LEAVE THESE VARIABLES ALONE UNLESS SOMETHING'S NOT WORKING ###########
cd $rawDir

### Environment variables
# # Many of the tools are installed locally in Keaton's home directory
# # To make sure you're using the right tools, add the following directory to you path
# # either by running the following command or by adding it to your .bash_profile/.bashrc
# export PATH=/home/micro/stagamak/bin:$PATH
today=(`date`)
runName=`echo "process_16S_${today[2]}${today[1]}${today[5]}"`
echo "1_assemble_filter_cat_16.job" >> $rawDir/$runName.log
echo "rawDir=$rawDir" >> $rawDir/$runName.log
echo "scriptsDir=$scriptsDir" >> $rawDir/$runName.log
read1s=(`ls *-R1.fastq.gz`) # this makes a list of the appropriate read1 files
read2s=(`ls *-R2.fastq.gz`) # this does the same for read2s and they should match in order
if [[ ${#read1s[@]} -eq 0 ]]; then 
    if [[ ${#read2s[@]} -eq 0 ]]; then
        echo -e "\tThere are no read files present in the directory using the proper naming convention" && \
        echo -e "\t(sample_name-R1.fastq, sample_name-R2.fastq)\n"
        # exit
    else
        echo -e "\tThere are no read 1 files present in the directory using the proper naming convention" && \
        echo -e "\t(sample_name-R1.fastq)\n"
        # exit
    fi
else
    if [[ ${#read2s[@]} -eq 0 ]]; then
    echo -e "\tThere are no read 2 files present in the directory using the proper naming convention" && \
    echo -e "\t(sample_name-R2.fastq)\n"
    # exit
    fi
fi
flash_end=`expr ${#read1s[@]} - 1`
flash_outDir=01_Flash_m${flash_minOverlap}M${flash_maxOverlap}
qual_outDir=02_Filtered_q${qual_min}p${qual_pct}
concatName=all_smpls.joined.filt
uniq_outDir=03_UniqSeq_files

##################################################################################
######################### PROCESSING COMMANDS RUN BELOW ##########################

### Read assembly (flash)
mkdir -p $flash_outDir
for i in `seq 0 $flash_end`; do 
    name=${read1s[$i]%-R[12]*}
    flash_cmd="flash -m $flash_minOverlap \
                     -M $flash_maxOverlap \
                     -x $flash_mismatch 
                     -o $flash_outDir/$name \
                     -t $nproc \
                     --compress \
                     ${read1s[$i]} \
                     ${read2s[$i]}"
    eval $flash_cmd
    # flash -m $flash_minOverlap -M $flash_maxOverlap -x $flash_mismatch -o $flash_outDir/$name ${read1s[$i]} ${read2s[$i]}
done
echo $flash_cmd >> $rawDir/$runName.log

cd $flash_outDir

### Clean up 
mkdir -p Flash_notCombined
mkdir -p Flash_histograms
mv *.notCombined* Flash_notCombined
mv *.hist* Flash_histograms
$scriptsDir/batch_rename.sh "*extended*" extendedFrags joined

cd $rawDir

### Quality filtering (fastq_quality_filter)
mkdir -p $rawDir/$qual_outDir
for fq in $flash_outDir/*fastq.gz; do 
    name=`echo ${fq%.fastq.gz} | cut -d '/' -f 2`
    filter_cmd="zcat $fq | \
                fastq_quality_filter -q $qual_min \
                                     -p $qual_pct \
                                     -Q 33 \
                                     -z \
                                     -v \
                                     -o $qual_outDir/$name.filt.fastq.gz"
    eval $filter_cmd
done
echo $filter_cmd >> $rawDir/$runName.log

### Convert fastQs to fastAs (simple_fq2fa.pl)
cd $rawDir/$qual_outDir
for fq in *fastq.gz; do
    echo $fq
    seqtk seq -a $fq | gzip -v > ${fq%fastq.gz}fasta.gz
done

### Add sample names to fasta headers
for fa in *fasta.gz; do
    echo $fa 
    smpl=${fa%.joined*}
    zcat $fa | sed "s/^>..*/>$smpl/g" | gzip > ${fa}.edited
done
$scriptsDir/batch_rename.sh "*edited" gz.edited gz

### Concatenate files
mkdir -p $rawDir/$uniq_outDir
cat *fasta.gz > $rawDir/$uniq_outDir/$concatName.fasta.gz

cd $rawDir
