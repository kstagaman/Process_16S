#!/bin/bash -l
# 2_derep_cluster_ID_16S.job

### Use the script to dereplicate, cluster OTUs, and identitfy from 16S sequences.
### This script requires you to have run 1_assemble_filter_cat_16S.job on this same data

### Auxillary scripts and programs
# bowtie2
# vsearch
# mafft
# fasttree
# RDPTools
# uniq_16S.pl
# usearch7_relabel_otus.pl
# build_otu_table.pl
# join_multi-lined_fasta.pl
# rdp_tax2phyloseq_tax_nosupp.pl

###################### YOU CAN EDIT THE FOLLOWING VARIABLES ######################
rawDir=/ssd/stagamak_tmp/Practice_16S
scriptsDir=/home/micro/stagamak/scripts/Process_16S/Support_scripts
nproc=80 # number of processors to use during steps that allow parallelization


### What percent similarity to you want to use for clustering?
pct_id=0.97
#
### Include singletons by matching them back to clusters formed without them ("yes" or "no")?
inclSngls=no
uniq_keep=2 # mininum number of identical sequences to keep unique read

### Do you want to run bowtie2 to remove host-matching sequences ("yes" or "no")?
runBowtie=yes
bowtie_db=/home/micro/stagamak/databases/h_sapiens_bowtie2/all_GRCh38.p7   # bowtie2 human genome

bowtie_threads=1 # Using more than 1 thread causes bowtie to mess up the order of the unique sequences
                 # If you do this, you need to add a line after the bowtie command to reorder sequences by abundance

### Alignment parameters
mafft_open=10  # these open and extend penalties are much higher than the default. I chose them because I've found that
mafft_extend=5 # if the resulting alignments are highly gapped, I probably did something wrong upstream, or the data is really bad.

##################################################################################
########### LEAVE THESE VARIABLES ALONE UNLESS SOMETHING'S NOT WORKING ###########
cd $rawDir

### Environment variables
today=(`date`)
runName=`echo "process_16S_${today[2]}${today[1]}${today[5]}"`
echo "2_derep_cluster_ID_16S.job" >> $rawDir/$runName.log
echo "rawDir=$rawDir" >> $rawDir/$runName.log
echo "scriptsDir=$scriptsDir" >> $rawDir/$runName.log
echo "inclSngls=$inclSngls" >> $rawDir/$runName.log
concatName=all_smpls.joined.filt
uniq_outDir=03_UniqSeq_files
echo "uniq_keep=$uniq_keep" >> $rawDir/$runName.log
gt=`expr $uniq_keep - 1` # for file naming purposes
cluster_outDir=04_Vsearch_${pct_id}sim
final_outDir=00_Final_output
fasttree_log=$rawDir/${runName}_fasttree.log

##################################################################################
######################### PROCESSING COMMANDS RUN BELOW ##########################

### Dereplicate unique reads (uniq_16S.pl) &
### Drop unique reads with abundance lower than $uniq_keep
cd $rawDir/$uniq_outDir
if [ $inclSngls == 'yes' ]; then
    derep_cmd="$scriptsDir/uniq_16S.pl -s -u -i $concatName.fasta.gz -k $uniq_keep"
else
    derep_cmd="$scriptsDir/uniq_16S.pl -s -i $concatName.fasta.gz -k $uniq_keep"
fi
eval $derep_cmd
echo $derep_cmd >> $rawDir/$runName.log

overThreshName=all_smpls.joined.filt.uniq.gt${gt}.vsearch_hdrs
if [ $inclSngls == 'yes' ]; then
    underThreshName=all_smpls.joined.filt.uniq.lte${gt}.vsearch_hdrs
fi

### Drop seqs that align to host genome
seq_cts=(`zcat $overThreshName.fasta.gz | grep -o "size=[0-9][0-9]*" | cut -f 2 -d '='`)
last=$((${#seq_cts[@]} - 1))
total_seqs=0; for i in `seq 0 $last`; do total_seqs=$(($total_seqs + ${seq_cts[$i]})); done
if [ $runBowtie == 'yes' ]; then
    bowtie_cmd1="bowtie2 -f \
                        -x $bowtie_db \
                        -U $overThreshName.fasta.gz \
                        -S $overThreshName.sam \
                        --un-gz $overThreshName.noHost.fasta.gz \
                        --al-gz $overThreshName.wHost.fasta.gz \
                        -p $bowtie_threads \
                        -t"
    eval $bowtie_cmd1
    echo $bowtie_cmd1 >> $rawDir/$runName.log
    
    deHostOverName=$overThreshName.noHost
    hostSeq_cts=(`zcat $overThreshName.wHost.fasta | grep -o "size=[0-9][0-9]*" | cut -f 2 -d '='`)
    last=$((${#hostSeq_cts[@]} - 1))
    total_host=0; for i in `seq 0 $last`; do total_host=$(($total_host + ${hostSeq_cts[$i]})); done
    frac_host=`bc <<< "scale=5; $total_host/$total_seqs"`
    echo "fraction of seqs over keep threshold that match host: $frac_host" >> $rawDir/$runName.log

    if [ $inclSngls == 'yes' ]; then
        bowtie_cmd2="bowtie2 -f \
                             -x $bowtie_db \
                             -U $underThreshName.fasta.gz \
                             -S $underThreshName.sam \
                             --un-gz $underThreshName.noHost.fasta.gz \
                             --al-gz $underThreshName.wHost.fasta.gz \
                             -p $bowtie_threads \
                             -t"
        eval $bowtie_cmd2
        echo $bowtie_cmd2 >> $rawDir/$runName.log
        
        deHostUnderName=$underThreshName.noHost
        hostSeq_cts=(`zcat $underThreshName.wHost.fasta | grep -o "size=[0-9][0-9]*" | cut -f 2 -d '='`)
        last=$((${#hostSeq_cts[@]} - 1))
        total_host=0; for i in `seq 0 $last`; do total_host=$(($total_host + ${hostSeq_cts[$i]})); done
        frac_host=`bc <<< "scale=5; $total_host/$total_seqs"`
        echo "fraction of seqs under keep threshold that match host: $frac_host" >> $rawDir/$runName.log
    fi
else
    deHostOverName=$overThreshName
    deHostUnderName=$underThreshName
fi

### Cluster OTUs (usearch)
cd $rawDir
mkdir $rawDir/$cluster_outDir

vsearch_cmd1="vsearch --gzip_decompress \
                      --cluster_size $uniq_outDir/$deHostOverName.fasta.gz \
                      --centroids $cluster_outDir/$deHostOverName.seeds.fasta \
                      --uc $cluster_outDir/$deHostOverName.clustered.uc \
                      --sizein \
                      --id $pct_id"
eval $vsearch_cmd1
echo $vsearch_cmd1 >> $rawDir/$runName.log
# gzip here?

if [ $inclSngls == 'yes' ]; then
    vsearch_cmd2="vsearch --usearch_global $uniq_outDir/$deHostUnderName.fasta \
                          --db $cluster_outDir/$deHostOverName.seeds.fasta \
                          --uc $cluster_outDir/$deHostUnderName.clustered.uc \
                          --sizein \
                          --strand plus \
                          --id $pct_id"
    eval $vsearch_cmd2
    echo $vsearch_cmd2 >> $rawDir/$runName.log
fi

### Cleanup
comboName=$concatName.uniq.allSize.noHost
grep "^[SH]" $cluster_outDir/$deHostOverName.clustered.uc > $cluster_outDir/$comboName.clustered.uc
cat $uniq_outDir/$concatName.uniq_gt${gt}_map.txt > $uniq_outDir/$concatName.uniq_allSize_map.txt

if [ $inclSngls == 'yes' ]; then
    grep "^[SH]" $cluster_outDir/$deHostUnderName.clustered.uc >> $cluster_outDir/$comboName.clustered.uc
    cat $uniq_outDir/$concatName.uniq_lte${gt}_map.txt >> $uniq_outDir/$concatName.uniq_allSize_map.txt
fi

$scriptsDir/join_multi-lined_fasta.pl $cluster_outDir/$deHostOverName.seeds.fasta
mv $cluster_outDir/$deHostOverName.seeds.fasta.joined $cluster_outDir/$deHostOverName.seeds.fasta
$scriptsDir/usearch7_relabel_otus.pl -i $cluster_outDir/$deHostOverName.seeds.fasta
mv $cluster_outDir/$deHostOverName.seeds.relabelled.fasta $cluster_outDir/$deHostOverName.seeds.fasta

### Build OTU table
mkdir $rawDir/$final_outDir
otu_tbl_cmd="$scriptsDir/build_otu_table.pl -f uclust \
                                            -o $final_outDir \
                                            -i $cluster_outDir/$comboName.clustered.uc \
                                            -m $uniq_outDir/$concatName.uniq_allSize_map.txt"
eval $otu_tbl_cmd
echo $otu_tbl_cmd >> $rawDir/$runName.log
mv $final_outDir/$comboName.clustered.otu_tbl.txt $final_outDir/all_smpls.otu_tbl.txt

### Alignment (mafft)
cd $rawDir/$cluster_outDir
mafft_cmd="mafft --auto \
                 --op $mafft_open \
                 --ep $mafft_extend \
                 --thread $nproc \
                 $deHostOverName.seeds.fasta > \
                 $rawDir/$final_outDir/all_smpls.otu_seqs.aln.fasta"
eval $mafft_cmd
echo $mafft_cmd >> $rawDir/$runName.log

### Cleanup
cd $rawDir/$final_outDir
$scriptsDir/join_multi-lined_fasta.pl all_smpls.otu_seqs.aln.fasta
mv all_smpls.otu_seqs.aln.fasta.joined all_smpls.otu_seqs.aln.fasta

### Build tree (FastTree)
# If you don't want FastTreeMP to use all of the cores on your machine, 
# you can use the OMP_NUM_THREADS environment variable to control its behavior 
# (e.g., in a Unix shell, use export OMP_NUM_THREADS=3). 
# If you run FastTreeMP -help, it will tell you how many threads it will use.
export OMP_NUM_THREADS=$nproc
fasttree_cmd="FastTreeMP -nt \
                         -nosupport \
                         -quote \
                         -gtr \
                         -gamma \
                         -log $fasttree_log \
                         all_smpls.otu_seqs.aln.fasta > \
                         all_smpls.otus.tree"
eval $fasttree_cmd
echo $fasttree_cmd >> $rawDir/$runName.log

### Taxon assignment (RDP classifier)
classify_cmd="java -Xmx8g \
                   -jar /home/micro/stagamak/src/RDPTools/classifier.jar \
                   classify \
                   all_smpls.otu_seqs.aln.fasta \
                   -o all_smpls.taxa_tbl.rdp.txt"
eval $classify_cmd
echo $classify_cmd >> $rawDir/$runName.log

$scriptsDir/rdp_tax2phyloseq_tax_nosupp.pl -i all_smpls.taxa_tbl.rdp.txt

cd $rawDir
